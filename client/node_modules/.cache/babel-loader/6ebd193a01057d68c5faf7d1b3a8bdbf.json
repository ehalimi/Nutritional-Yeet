{"ast":null,"code":"import _inherits from \"/Users/emahalimi/projects/book-search/client/node_modules/@babel/runtime/helpers/esm/inherits.js\";\nimport _createSuper from \"/Users/emahalimi/projects/book-search/client/node_modules/@babel/runtime/helpers/esm/createSuper.js\";\nimport _createForOfIteratorHelper from \"/Users/emahalimi/projects/book-search/client/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper.js\";\nimport _classCallCheck from \"/Users/emahalimi/projects/book-search/client/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/Users/emahalimi/projects/book-search/client/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport { Kind } from '../language/kinds.mjs';\nimport { visit } from '../language/visitor.mjs';\nimport { TypeInfo, visitWithTypeInfo } from '../utilities/TypeInfo.mjs';\n\n/**\n * An instance of this class is passed as the \"this\" context to all validators,\n * allowing access to commonly useful contextual information from within a\n * validation rule.\n */\nexport var ASTValidationContext = /*#__PURE__*/function (_Symbol$toStringTag) {\n  function ASTValidationContext(ast, onError) {\n    _classCallCheck(this, ASTValidationContext);\n    this._ast = ast;\n    this._fragments = undefined;\n    this._fragmentSpreads = new Map();\n    this._recursivelyReferencedFragments = new Map();\n    this._onError = onError;\n  }\n  _createClass(ASTValidationContext, [{\n    key: _Symbol$toStringTag,\n    get: function get() {\n      return 'ASTValidationContext';\n    }\n  }, {\n    key: \"reportError\",\n    value: function reportError(error) {\n      this._onError(error);\n    }\n  }, {\n    key: \"getDocument\",\n    value: function getDocument() {\n      return this._ast;\n    }\n  }, {\n    key: \"getFragment\",\n    value: function getFragment(name) {\n      var fragments;\n      if (this._fragments) {\n        fragments = this._fragments;\n      } else {\n        fragments = Object.create(null);\n        var _iterator = _createForOfIteratorHelper(this.getDocument().definitions),\n          _step;\n        try {\n          for (_iterator.s(); !(_step = _iterator.n()).done;) {\n            var defNode = _step.value;\n            if (defNode.kind === Kind.FRAGMENT_DEFINITION) {\n              fragments[defNode.name.value] = defNode;\n            }\n          }\n        } catch (err) {\n          _iterator.e(err);\n        } finally {\n          _iterator.f();\n        }\n        this._fragments = fragments;\n      }\n      return fragments[name];\n    }\n  }, {\n    key: \"getFragmentSpreads\",\n    value: function getFragmentSpreads(node) {\n      var spreads = this._fragmentSpreads.get(node);\n      if (!spreads) {\n        spreads = [];\n        var setsToVisit = [node];\n        var set;\n        while (set = setsToVisit.pop()) {\n          var _iterator2 = _createForOfIteratorHelper(set.selections),\n            _step2;\n          try {\n            for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n              var selection = _step2.value;\n              if (selection.kind === Kind.FRAGMENT_SPREAD) {\n                spreads.push(selection);\n              } else if (selection.selectionSet) {\n                setsToVisit.push(selection.selectionSet);\n              }\n            }\n          } catch (err) {\n            _iterator2.e(err);\n          } finally {\n            _iterator2.f();\n          }\n        }\n        this._fragmentSpreads.set(node, spreads);\n      }\n      return spreads;\n    }\n  }, {\n    key: \"getRecursivelyReferencedFragments\",\n    value: function getRecursivelyReferencedFragments(operation) {\n      var fragments = this._recursivelyReferencedFragments.get(operation);\n      if (!fragments) {\n        fragments = [];\n        var collectedNames = Object.create(null);\n        var nodesToVisit = [operation.selectionSet];\n        var node;\n        while (node = nodesToVisit.pop()) {\n          var _iterator3 = _createForOfIteratorHelper(this.getFragmentSpreads(node)),\n            _step3;\n          try {\n            for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n              var spread = _step3.value;\n              var fragName = spread.name.value;\n              if (collectedNames[fragName] !== true) {\n                collectedNames[fragName] = true;\n                var fragment = this.getFragment(fragName);\n                if (fragment) {\n                  fragments.push(fragment);\n                  nodesToVisit.push(fragment.selectionSet);\n                }\n              }\n            }\n          } catch (err) {\n            _iterator3.e(err);\n          } finally {\n            _iterator3.f();\n          }\n        }\n        this._recursivelyReferencedFragments.set(operation, fragments);\n      }\n      return fragments;\n    }\n  }]);\n  return ASTValidationContext;\n}(Symbol.toStringTag);\nexport var SDLValidationContext = /*#__PURE__*/function (_ASTValidationContext, _Symbol$toStringTag2) {\n  _inherits(SDLValidationContext, _ASTValidationContext);\n  var _super = _createSuper(SDLValidationContext);\n  function SDLValidationContext(ast, schema, onError) {\n    var _this;\n    _classCallCheck(this, SDLValidationContext);\n    _this = _super.call(this, ast, onError);\n    _this._schema = schema;\n    return _this;\n  }\n  _createClass(SDLValidationContext, [{\n    key: _Symbol$toStringTag2,\n    get: function get() {\n      return 'SDLValidationContext';\n    }\n  }, {\n    key: \"getSchema\",\n    value: function getSchema() {\n      return this._schema;\n    }\n  }]);\n  return SDLValidationContext;\n}(ASTValidationContext, Symbol.toStringTag);\nexport var ValidationContext = /*#__PURE__*/function (_ASTValidationContext2, _Symbol$toStringTag3) {\n  _inherits(ValidationContext, _ASTValidationContext2);\n  var _super2 = _createSuper(ValidationContext);\n  function ValidationContext(schema, ast, typeInfo, onError) {\n    var _this2;\n    _classCallCheck(this, ValidationContext);\n    _this2 = _super2.call(this, ast, onError);\n    _this2._schema = schema;\n    _this2._typeInfo = typeInfo;\n    _this2._variableUsages = new Map();\n    _this2._recursiveVariableUsages = new Map();\n    return _this2;\n  }\n  _createClass(ValidationContext, [{\n    key: _Symbol$toStringTag3,\n    get: function get() {\n      return 'ValidationContext';\n    }\n  }, {\n    key: \"getSchema\",\n    value: function getSchema() {\n      return this._schema;\n    }\n  }, {\n    key: \"getVariableUsages\",\n    value: function getVariableUsages(node) {\n      var usages = this._variableUsages.get(node);\n      if (!usages) {\n        var newUsages = [];\n        var typeInfo = new TypeInfo(this._schema);\n        visit(node, visitWithTypeInfo(typeInfo, {\n          VariableDefinition: function VariableDefinition() {\n            return false;\n          },\n          Variable: function Variable(variable) {\n            newUsages.push({\n              node: variable,\n              type: typeInfo.getInputType(),\n              defaultValue: typeInfo.getDefaultValue()\n            });\n          }\n        }));\n        usages = newUsages;\n        this._variableUsages.set(node, usages);\n      }\n      return usages;\n    }\n  }, {\n    key: \"getRecursiveVariableUsages\",\n    value: function getRecursiveVariableUsages(operation) {\n      var usages = this._recursiveVariableUsages.get(operation);\n      if (!usages) {\n        usages = this.getVariableUsages(operation);\n        var _iterator4 = _createForOfIteratorHelper(this.getRecursivelyReferencedFragments(operation)),\n          _step4;\n        try {\n          for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {\n            var frag = _step4.value;\n            usages = usages.concat(this.getVariableUsages(frag));\n          }\n        } catch (err) {\n          _iterator4.e(err);\n        } finally {\n          _iterator4.f();\n        }\n        this._recursiveVariableUsages.set(operation, usages);\n      }\n      return usages;\n    }\n  }, {\n    key: \"getType\",\n    value: function getType() {\n      return this._typeInfo.getType();\n    }\n  }, {\n    key: \"getParentType\",\n    value: function getParentType() {\n      return this._typeInfo.getParentType();\n    }\n  }, {\n    key: \"getInputType\",\n    value: function getInputType() {\n      return this._typeInfo.getInputType();\n    }\n  }, {\n    key: \"getParentInputType\",\n    value: function getParentInputType() {\n      return this._typeInfo.getParentInputType();\n    }\n  }, {\n    key: \"getFieldDef\",\n    value: function getFieldDef() {\n      return this._typeInfo.getFieldDef();\n    }\n  }, {\n    key: \"getDirective\",\n    value: function getDirective() {\n      return this._typeInfo.getDirective();\n    }\n  }, {\n    key: \"getArgument\",\n    value: function getArgument() {\n      return this._typeInfo.getArgument();\n    }\n  }, {\n    key: \"getEnumValue\",\n    value: function getEnumValue() {\n      return this._typeInfo.getEnumValue();\n    }\n  }]);\n  return ValidationContext;\n}(ASTValidationContext, Symbol.toStringTag);","map":{"version":3,"names":["Kind","visit","TypeInfo","visitWithTypeInfo","ASTValidationContext","ast","onError","_ast","_fragments","undefined","_fragmentSpreads","Map","_recursivelyReferencedFragments","_onError","error","name","fragments","Object","create","getDocument","definitions","defNode","kind","FRAGMENT_DEFINITION","value","node","spreads","get","setsToVisit","set","pop","selections","selection","FRAGMENT_SPREAD","push","selectionSet","operation","collectedNames","nodesToVisit","getFragmentSpreads","spread","fragName","fragment","getFragment","Symbol","toStringTag","SDLValidationContext","schema","_schema","ValidationContext","typeInfo","_typeInfo","_variableUsages","_recursiveVariableUsages","usages","newUsages","VariableDefinition","Variable","variable","type","getInputType","defaultValue","getDefaultValue","getVariableUsages","getRecursivelyReferencedFragments","frag","concat","getType","getParentType","getParentInputType","getFieldDef","getDirective","getArgument","getEnumValue"],"sources":["/Users/emahalimi/projects/book-search/client/node_modules/graphql/validation/ValidationContext.mjs"],"sourcesContent":["import { Kind } from '../language/kinds.mjs';\nimport { visit } from '../language/visitor.mjs';\nimport { TypeInfo, visitWithTypeInfo } from '../utilities/TypeInfo.mjs';\n\n/**\n * An instance of this class is passed as the \"this\" context to all validators,\n * allowing access to commonly useful contextual information from within a\n * validation rule.\n */\nexport class ASTValidationContext {\n  constructor(ast, onError) {\n    this._ast = ast;\n    this._fragments = undefined;\n    this._fragmentSpreads = new Map();\n    this._recursivelyReferencedFragments = new Map();\n    this._onError = onError;\n  }\n\n  get [Symbol.toStringTag]() {\n    return 'ASTValidationContext';\n  }\n\n  reportError(error) {\n    this._onError(error);\n  }\n\n  getDocument() {\n    return this._ast;\n  }\n\n  getFragment(name) {\n    let fragments;\n\n    if (this._fragments) {\n      fragments = this._fragments;\n    } else {\n      fragments = Object.create(null);\n\n      for (const defNode of this.getDocument().definitions) {\n        if (defNode.kind === Kind.FRAGMENT_DEFINITION) {\n          fragments[defNode.name.value] = defNode;\n        }\n      }\n\n      this._fragments = fragments;\n    }\n\n    return fragments[name];\n  }\n\n  getFragmentSpreads(node) {\n    let spreads = this._fragmentSpreads.get(node);\n\n    if (!spreads) {\n      spreads = [];\n      const setsToVisit = [node];\n      let set;\n\n      while ((set = setsToVisit.pop())) {\n        for (const selection of set.selections) {\n          if (selection.kind === Kind.FRAGMENT_SPREAD) {\n            spreads.push(selection);\n          } else if (selection.selectionSet) {\n            setsToVisit.push(selection.selectionSet);\n          }\n        }\n      }\n\n      this._fragmentSpreads.set(node, spreads);\n    }\n\n    return spreads;\n  }\n\n  getRecursivelyReferencedFragments(operation) {\n    let fragments = this._recursivelyReferencedFragments.get(operation);\n\n    if (!fragments) {\n      fragments = [];\n      const collectedNames = Object.create(null);\n      const nodesToVisit = [operation.selectionSet];\n      let node;\n\n      while ((node = nodesToVisit.pop())) {\n        for (const spread of this.getFragmentSpreads(node)) {\n          const fragName = spread.name.value;\n\n          if (collectedNames[fragName] !== true) {\n            collectedNames[fragName] = true;\n            const fragment = this.getFragment(fragName);\n\n            if (fragment) {\n              fragments.push(fragment);\n              nodesToVisit.push(fragment.selectionSet);\n            }\n          }\n        }\n      }\n\n      this._recursivelyReferencedFragments.set(operation, fragments);\n    }\n\n    return fragments;\n  }\n}\nexport class SDLValidationContext extends ASTValidationContext {\n  constructor(ast, schema, onError) {\n    super(ast, onError);\n    this._schema = schema;\n  }\n\n  get [Symbol.toStringTag]() {\n    return 'SDLValidationContext';\n  }\n\n  getSchema() {\n    return this._schema;\n  }\n}\nexport class ValidationContext extends ASTValidationContext {\n  constructor(schema, ast, typeInfo, onError) {\n    super(ast, onError);\n    this._schema = schema;\n    this._typeInfo = typeInfo;\n    this._variableUsages = new Map();\n    this._recursiveVariableUsages = new Map();\n  }\n\n  get [Symbol.toStringTag]() {\n    return 'ValidationContext';\n  }\n\n  getSchema() {\n    return this._schema;\n  }\n\n  getVariableUsages(node) {\n    let usages = this._variableUsages.get(node);\n\n    if (!usages) {\n      const newUsages = [];\n      const typeInfo = new TypeInfo(this._schema);\n      visit(\n        node,\n        visitWithTypeInfo(typeInfo, {\n          VariableDefinition: () => false,\n\n          Variable(variable) {\n            newUsages.push({\n              node: variable,\n              type: typeInfo.getInputType(),\n              defaultValue: typeInfo.getDefaultValue(),\n            });\n          },\n        }),\n      );\n      usages = newUsages;\n\n      this._variableUsages.set(node, usages);\n    }\n\n    return usages;\n  }\n\n  getRecursiveVariableUsages(operation) {\n    let usages = this._recursiveVariableUsages.get(operation);\n\n    if (!usages) {\n      usages = this.getVariableUsages(operation);\n\n      for (const frag of this.getRecursivelyReferencedFragments(operation)) {\n        usages = usages.concat(this.getVariableUsages(frag));\n      }\n\n      this._recursiveVariableUsages.set(operation, usages);\n    }\n\n    return usages;\n  }\n\n  getType() {\n    return this._typeInfo.getType();\n  }\n\n  getParentType() {\n    return this._typeInfo.getParentType();\n  }\n\n  getInputType() {\n    return this._typeInfo.getInputType();\n  }\n\n  getParentInputType() {\n    return this._typeInfo.getParentInputType();\n  }\n\n  getFieldDef() {\n    return this._typeInfo.getFieldDef();\n  }\n\n  getDirective() {\n    return this._typeInfo.getDirective();\n  }\n\n  getArgument() {\n    return this._typeInfo.getArgument();\n  }\n\n  getEnumValue() {\n    return this._typeInfo.getEnumValue();\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}