{"ast":null,"code":"import _createForOfIteratorHelper from \"/Users/emahalimi/projects/book-search/client/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper.js\";\nimport _objectSpread from \"/Users/emahalimi/projects/book-search/client/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nimport { inspect } from '../jsutils/inspect.mjs';\nimport { invariant } from '../jsutils/invariant.mjs';\nimport { keyValMap } from '../jsutils/keyValMap.mjs';\nimport { naturalCompare } from '../jsutils/naturalCompare.mjs';\nimport { GraphQLEnumType, GraphQLInputObjectType, GraphQLInterfaceType, GraphQLList, GraphQLNonNull, GraphQLObjectType, GraphQLUnionType, isEnumType, isInputObjectType, isInterfaceType, isListType, isNonNullType, isObjectType, isScalarType, isUnionType } from '../type/definition.mjs';\nimport { GraphQLDirective } from '../type/directives.mjs';\nimport { isIntrospectionType } from '../type/introspection.mjs';\nimport { GraphQLSchema } from '../type/schema.mjs';\n/**\n * Sort GraphQLSchema.\n *\n * This function returns a sorted copy of the given GraphQLSchema.\n */\n\nexport function lexicographicSortSchema(schema) {\n  var schemaConfig = schema.toConfig();\n  var typeMap = keyValMap(sortByName(schemaConfig.types), function (type) {\n    return type.name;\n  }, sortNamedType);\n  return new GraphQLSchema(_objectSpread(_objectSpread({}, schemaConfig), {}, {\n    types: Object.values(typeMap),\n    directives: sortByName(schemaConfig.directives).map(sortDirective),\n    query: replaceMaybeType(schemaConfig.query),\n    mutation: replaceMaybeType(schemaConfig.mutation),\n    subscription: replaceMaybeType(schemaConfig.subscription)\n  }));\n  function replaceType(type) {\n    if (isListType(type)) {\n      // @ts-expect-error\n      return new GraphQLList(replaceType(type.ofType));\n    } else if (isNonNullType(type)) {\n      // @ts-expect-error\n      return new GraphQLNonNull(replaceType(type.ofType));\n    } // @ts-expect-error FIXME: TS Conversion\n\n    return replaceNamedType(type);\n  }\n  function replaceNamedType(type) {\n    return typeMap[type.name];\n  }\n  function replaceMaybeType(maybeType) {\n    return maybeType && replaceNamedType(maybeType);\n  }\n  function sortDirective(directive) {\n    var config = directive.toConfig();\n    return new GraphQLDirective(_objectSpread(_objectSpread({}, config), {}, {\n      locations: sortBy(config.locations, function (x) {\n        return x;\n      }),\n      args: sortArgs(config.args)\n    }));\n  }\n  function sortArgs(args) {\n    return sortObjMap(args, function (arg) {\n      return _objectSpread(_objectSpread({}, arg), {}, {\n        type: replaceType(arg.type)\n      });\n    });\n  }\n  function sortFields(fieldsMap) {\n    return sortObjMap(fieldsMap, function (field) {\n      return _objectSpread(_objectSpread({}, field), {}, {\n        type: replaceType(field.type),\n        args: field.args && sortArgs(field.args)\n      });\n    });\n  }\n  function sortInputFields(fieldsMap) {\n    return sortObjMap(fieldsMap, function (field) {\n      return _objectSpread(_objectSpread({}, field), {}, {\n        type: replaceType(field.type)\n      });\n    });\n  }\n  function sortTypes(array) {\n    return sortByName(array).map(replaceNamedType);\n  }\n  function sortNamedType(type) {\n    if (isScalarType(type) || isIntrospectionType(type)) {\n      return type;\n    }\n    if (isObjectType(type)) {\n      var config = type.toConfig();\n      return new GraphQLObjectType(_objectSpread(_objectSpread({}, config), {}, {\n        interfaces: function interfaces() {\n          return sortTypes(config.interfaces);\n        },\n        fields: function fields() {\n          return sortFields(config.fields);\n        }\n      }));\n    }\n    if (isInterfaceType(type)) {\n      var _config = type.toConfig();\n      return new GraphQLInterfaceType(_objectSpread(_objectSpread({}, _config), {}, {\n        interfaces: function interfaces() {\n          return sortTypes(_config.interfaces);\n        },\n        fields: function fields() {\n          return sortFields(_config.fields);\n        }\n      }));\n    }\n    if (isUnionType(type)) {\n      var _config2 = type.toConfig();\n      return new GraphQLUnionType(_objectSpread(_objectSpread({}, _config2), {}, {\n        types: function types() {\n          return sortTypes(_config2.types);\n        }\n      }));\n    }\n    if (isEnumType(type)) {\n      var _config3 = type.toConfig();\n      return new GraphQLEnumType(_objectSpread(_objectSpread({}, _config3), {}, {\n        values: sortObjMap(_config3.values, function (value) {\n          return value;\n        })\n      }));\n    }\n    if (isInputObjectType(type)) {\n      var _config4 = type.toConfig();\n      return new GraphQLInputObjectType(_objectSpread(_objectSpread({}, _config4), {}, {\n        fields: function fields() {\n          return sortInputFields(_config4.fields);\n        }\n      }));\n    }\n    /* c8 ignore next 3 */\n    // Not reachable, all possible types have been considered.\n\n    false || invariant(false, 'Unexpected type: ' + inspect(type));\n  }\n}\nfunction sortObjMap(map, sortValueFn) {\n  var sortedMap = Object.create(null);\n  var _iterator = _createForOfIteratorHelper(Object.keys(map).sort(naturalCompare)),\n    _step;\n  try {\n    for (_iterator.s(); !(_step = _iterator.n()).done;) {\n      var key = _step.value;\n      sortedMap[key] = sortValueFn(map[key]);\n    }\n  } catch (err) {\n    _iterator.e(err);\n  } finally {\n    _iterator.f();\n  }\n  return sortedMap;\n}\nfunction sortByName(array) {\n  return sortBy(array, function (obj) {\n    return obj.name;\n  });\n}\nfunction sortBy(array, mapToKey) {\n  return array.slice().sort(function (obj1, obj2) {\n    var key1 = mapToKey(obj1);\n    var key2 = mapToKey(obj2);\n    return naturalCompare(key1, key2);\n  });\n}","map":{"version":3,"names":["inspect","invariant","keyValMap","naturalCompare","GraphQLEnumType","GraphQLInputObjectType","GraphQLInterfaceType","GraphQLList","GraphQLNonNull","GraphQLObjectType","GraphQLUnionType","isEnumType","isInputObjectType","isInterfaceType","isListType","isNonNullType","isObjectType","isScalarType","isUnionType","GraphQLDirective","isIntrospectionType","GraphQLSchema","lexicographicSortSchema","schema","schemaConfig","toConfig","typeMap","sortByName","types","type","name","sortNamedType","Object","values","directives","map","sortDirective","query","replaceMaybeType","mutation","subscription","replaceType","ofType","replaceNamedType","maybeType","directive","config","locations","sortBy","x","args","sortArgs","sortObjMap","arg","sortFields","fieldsMap","field","sortInputFields","sortTypes","array","interfaces","fields","value","sortValueFn","sortedMap","create","keys","sort","key","obj","mapToKey","slice","obj1","obj2","key1","key2"],"sources":["/Users/emahalimi/projects/book-search/client/node_modules/graphql/utilities/lexicographicSortSchema.mjs"],"sourcesContent":["import { inspect } from '../jsutils/inspect.mjs';\nimport { invariant } from '../jsutils/invariant.mjs';\nimport { keyValMap } from '../jsutils/keyValMap.mjs';\nimport { naturalCompare } from '../jsutils/naturalCompare.mjs';\nimport {\n  GraphQLEnumType,\n  GraphQLInputObjectType,\n  GraphQLInterfaceType,\n  GraphQLList,\n  GraphQLNonNull,\n  GraphQLObjectType,\n  GraphQLUnionType,\n  isEnumType,\n  isInputObjectType,\n  isInterfaceType,\n  isListType,\n  isNonNullType,\n  isObjectType,\n  isScalarType,\n  isUnionType,\n} from '../type/definition.mjs';\nimport { GraphQLDirective } from '../type/directives.mjs';\nimport { isIntrospectionType } from '../type/introspection.mjs';\nimport { GraphQLSchema } from '../type/schema.mjs';\n/**\n * Sort GraphQLSchema.\n *\n * This function returns a sorted copy of the given GraphQLSchema.\n */\n\nexport function lexicographicSortSchema(schema) {\n  const schemaConfig = schema.toConfig();\n  const typeMap = keyValMap(\n    sortByName(schemaConfig.types),\n    (type) => type.name,\n    sortNamedType,\n  );\n  return new GraphQLSchema({\n    ...schemaConfig,\n    types: Object.values(typeMap),\n    directives: sortByName(schemaConfig.directives).map(sortDirective),\n    query: replaceMaybeType(schemaConfig.query),\n    mutation: replaceMaybeType(schemaConfig.mutation),\n    subscription: replaceMaybeType(schemaConfig.subscription),\n  });\n\n  function replaceType(type) {\n    if (isListType(type)) {\n      // @ts-expect-error\n      return new GraphQLList(replaceType(type.ofType));\n    } else if (isNonNullType(type)) {\n      // @ts-expect-error\n      return new GraphQLNonNull(replaceType(type.ofType));\n    } // @ts-expect-error FIXME: TS Conversion\n\n    return replaceNamedType(type);\n  }\n\n  function replaceNamedType(type) {\n    return typeMap[type.name];\n  }\n\n  function replaceMaybeType(maybeType) {\n    return maybeType && replaceNamedType(maybeType);\n  }\n\n  function sortDirective(directive) {\n    const config = directive.toConfig();\n    return new GraphQLDirective({\n      ...config,\n      locations: sortBy(config.locations, (x) => x),\n      args: sortArgs(config.args),\n    });\n  }\n\n  function sortArgs(args) {\n    return sortObjMap(args, (arg) => ({ ...arg, type: replaceType(arg.type) }));\n  }\n\n  function sortFields(fieldsMap) {\n    return sortObjMap(fieldsMap, (field) => ({\n      ...field,\n      type: replaceType(field.type),\n      args: field.args && sortArgs(field.args),\n    }));\n  }\n\n  function sortInputFields(fieldsMap) {\n    return sortObjMap(fieldsMap, (field) => ({\n      ...field,\n      type: replaceType(field.type),\n    }));\n  }\n\n  function sortTypes(array) {\n    return sortByName(array).map(replaceNamedType);\n  }\n\n  function sortNamedType(type) {\n    if (isScalarType(type) || isIntrospectionType(type)) {\n      return type;\n    }\n\n    if (isObjectType(type)) {\n      const config = type.toConfig();\n      return new GraphQLObjectType({\n        ...config,\n        interfaces: () => sortTypes(config.interfaces),\n        fields: () => sortFields(config.fields),\n      });\n    }\n\n    if (isInterfaceType(type)) {\n      const config = type.toConfig();\n      return new GraphQLInterfaceType({\n        ...config,\n        interfaces: () => sortTypes(config.interfaces),\n        fields: () => sortFields(config.fields),\n      });\n    }\n\n    if (isUnionType(type)) {\n      const config = type.toConfig();\n      return new GraphQLUnionType({\n        ...config,\n        types: () => sortTypes(config.types),\n      });\n    }\n\n    if (isEnumType(type)) {\n      const config = type.toConfig();\n      return new GraphQLEnumType({\n        ...config,\n        values: sortObjMap(config.values, (value) => value),\n      });\n    }\n\n    if (isInputObjectType(type)) {\n      const config = type.toConfig();\n      return new GraphQLInputObjectType({\n        ...config,\n        fields: () => sortInputFields(config.fields),\n      });\n    }\n    /* c8 ignore next 3 */\n    // Not reachable, all possible types have been considered.\n\n    false || invariant(false, 'Unexpected type: ' + inspect(type));\n  }\n}\n\nfunction sortObjMap(map, sortValueFn) {\n  const sortedMap = Object.create(null);\n\n  for (const key of Object.keys(map).sort(naturalCompare)) {\n    sortedMap[key] = sortValueFn(map[key]);\n  }\n\n  return sortedMap;\n}\n\nfunction sortByName(array) {\n  return sortBy(array, (obj) => obj.name);\n}\n\nfunction sortBy(array, mapToKey) {\n  return array.slice().sort((obj1, obj2) => {\n    const key1 = mapToKey(obj1);\n    const key2 = mapToKey(obj2);\n    return naturalCompare(key1, key2);\n  });\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}